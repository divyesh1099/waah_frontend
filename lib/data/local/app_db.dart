import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:io';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
// This is the only import needed for native libraries
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';

// This import is generated by build_runner.
part 'app_db.g.dart';

// --- Schema Definition ---

@DataClassName('MenuCategory')
class MenuCategories extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  TextColumn get name => text()();
  IntColumn get position => integer().withDefault(const Constant(0))();
}

@DataClassName('MenuItem')
class MenuItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  IntColumn get categoryId => integer()
      .references(MenuCategories, #id, onDelete: KeyAction.cascade)();
  TextColumn get name => text()();
  TextColumn get description => text().nullable()();
  TextColumn get sku => text().nullable()();
  TextColumn get hsn => text().nullable()();
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  BoolColumn get stockOut => boolean().withDefault(const Constant(false))();
  BoolColumn get taxInclusive => boolean().withDefault(const Constant(true))();
  RealColumn get gstRate => real().withDefault(const Constant(5.0))();
  TextColumn get kitchenStationId => text().nullable()();
  TextColumn get imageUrl => text().nullable()();
}

@DataClassName('ItemVariant')
class ItemVariants extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  IntColumn get itemId => integer()
      .references(MenuItems, #id, onDelete: KeyAction.cascade)();
  TextColumn get label => text()();
  RealColumn get mrp => real().nullable()();
  RealColumn get basePrice => real()();
  BoolColumn get isDefault => boolean().withDefault(const Constant(false))();
  TextColumn get imageUrl => text().nullable()();
}

@DataClassName('DiningTable')
class DiningTables extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  TextColumn get name => text()();
  TextColumn get status => text().withDefault(const Constant('free'))();
}

@DataClassName('OpsJournalEntry')
class OpsJournal extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get kind => text()();
  TextColumn get payload => text()();
  DateTimeColumn get createdAt => dateTime()();
}

@DataClassName('RestaurantSetting')
class RestaurantSettings extends Table {
  IntColumn get id => integer().withDefault(const Constant(1))();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  TextColumn get tenantId => text().nullable()();
  TextColumn get branchId => text().nullable()();
  TextColumn get name => text().withDefault(const Constant(''))();
  TextColumn get logoUrl => text().nullable()();
  TextColumn get address => text().nullable()();
  TextColumn get phone => text().nullable()();
  TextColumn get gstin => text().nullable()();
  TextColumn get fssai => text().nullable()();
  BoolColumn get printFssaiOnInvoice => boolean().withDefault(const Constant(false))();
  BoolColumn get gstInclusiveDefault => boolean().withDefault(const Constant(true))();
  TextColumn get serviceChargeMode => text().withDefault(const Constant('NONE'))();
  RealColumn get serviceChargeValue => real().withDefault(const Constant(0.0))();
  TextColumn get packingChargeMode => text().withDefault(const Constant('NONE'))();
  RealColumn get packingChargeValue => real().withDefault(const Constant(0.0))();
  TextColumn get billingPrinterId => text().nullable()();
  TextColumn get invoiceFooter => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// --- Database Class ---

@DriftDatabase(tables: [
  MenuCategories,
  MenuItems,
  ItemVariants,
  DiningTables,
  OpsJournal,
  RestaurantSettings,
])
class AppDatabase extends _$AppDatabase {
  AppDatabase(super.e);

  // *** BUMPED SCHEMA VERSION ***
  @override
  int get schemaVersion => 3; // Was 2, now 3

  // This is a helper function to safely drop a table if it exists
  Future<void> _dropTableIfExists(Migrator m, String tableName) async {
    try {
      // CORRECTED: Use issueCustomQuery instead of rawQuery
      await m.issueCustomQuery('DROP TABLE IF EXISTS $tableName;');
    } catch (e) {
      print('Could not drop table $tableName: $e');
    }
  }

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (m) => m.createAll(),
    onUpgrade: (m, from, to) async {
      // This logic will run because we bumped the version to 3.
      // It will delete all old tables and create the new correct ones.
      if (from < 3) {
        // Simple and robust: just recreate everything safely
        await _dropTableIfExists(m, 'menu_categories');
        await _dropTableIfExists(m, 'menu_items');
        await _dropTableIfExists(m, 'item_variants');
        await _dropTableIfExists(m, 'dining_tables');
        await _dropTableIfExists(m, 'ops_journal');
        await _dropTableIfExists(m, 'restaurant_settings');

        await m.createAll();
      }
    },
  );

  // --- Data Access Methods (DAOs) ---
  Stream<List<MenuCategory>> watchCategories() =>
      select(menuCategories).watch();
  Stream<List<MenuItem>> watchItemsInCategory(int catId) =>
      (select(menuItems)..where((t) => t.categoryId.equals(catId))).watch();
  Stream<List<ItemVariant>> watchVariantsForItem(int itemId) =>
      (select(itemVariants)..where((t) => t.itemId.equals(itemId))).watch();
  Stream<List<DiningTable>> watchDiningTables() =>
      select(diningTables).watch();
  Stream<RestaurantSetting?> watchSettings() =>
      (select(restaurantSettings)..where((t) => t.id.equals(1)))
          .watchSingleOrNull();
  Future<void> upsertCategory(MenuCategoriesCompanion companion) =>
      into(menuCategories).insertOnConflictUpdate(companion);
  Future<void> upsertMenuItem(MenuItemsCompanion companion) =>
      into(menuItems).insertOnConflictUpdate(companion);
  Future<void> upsertItemVariant(ItemVariantsCompanion companion) =>
      into(itemVariants).insertOnConflictUpdate(companion);
  Future<void> upsertDiningTable(DiningTablesCompanion companion) =>
      into(diningTables).insertOnConflictUpdate(companion);
  Future<void> upsertSettings(RestaurantSettingsCompanion companion) =>
      into(restaurantSettings).insertOnConflictUpdate(companion);
  Future<void> addPendingOp(OpsJournalCompanion op) =>
      into(opsJournal).insert(op);
  Future<List<OpsJournalEntry>> getPendingOps() =>
      select(opsJournal).get();
  Future<void> clearPendingOps(List<int> ids) =>
      (delete(opsJournal)..where((t) => t.id.isIn(ids))).go();

// --- helpers you can paste inside AppDatabase ---

  Future<void> clearMenu() async {
    await transaction(() async {
      await delete(itemVariants).go();
      await delete(menuItems).go();
      await delete(menuCategories).go();
    });
  }

  Future<MenuCategory?> findCategoryByRid(String rid) {
    return (select(menuCategories)..where((t) => t.remoteId.equals(rid)))
        .getSingleOrNull();
  }

  Future<MenuItem?> findItemByRid(String rid) {
    return (select(menuItems)..where((t) => t.remoteId.equals(rid)))
        .getSingleOrNull();
  }
}

// --- Connection & Provider ---

final localDatabaseProvider = Provider<AppDatabase>((ref) {
  final db = AppDatabase(_openConnection());
  ref.onDispose(db.close);
  return db;
});

// CORRECTED: Simplified connection logic
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'waah_pos.db'));

    // This is all that's needed.
    // The sqlite3_flutter_libs package will handle bundling the
    // native libraries for desktop automatically.
    return NativeDatabase(file);
  });
}

