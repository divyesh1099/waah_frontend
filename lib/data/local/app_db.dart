// lib/data/local/app_db.dart

import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:io';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
// We only need this import. It provides the bundling for desktop.
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';
// We no longer need 'package:sqlite3/sqlite3.dart'

// This import is generated by build_runner. It MUST come AFTER imports.
part 'app_db.g.dart';

// --- Schema Definition ---
// (These are all correct from before)

@DataClassName('MenuCategory')
class MenuCategories extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  TextColumn get name => text()();
  IntColumn get position => integer().withDefault(const Constant(0))();
}

@DataClassName('MenuItem')
class MenuItems extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  IntColumn get categoryId => integer()
      .references(MenuCategories, #id, onDelete: KeyAction.cascade)();
  TextColumn get name => text()();
  RealColumn get price => real()();
}

@DataClassName('ItemVariant')
class ItemVariants extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().named('rid').nullable()();
  IntColumn get itemId => integer()
      .references(MenuItems, #id, onDelete: KeyAction.cascade)();
  TextColumn get name => text()();
  RealColumn get priceDelta => real().withDefault(const Constant(0.0))();
}

@DataClassName('DiningTable')
class DiningTables extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get remoteId => text().unique().nullable()();
  TextColumn get name => text()();
  TextColumn get status => text()(); // 'free' | 'occupied'
}

@DataClassName('OpsJournalEntry')
class OpsJournal extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get kind => text()();
  TextColumn get payload => text()();
  DateTimeColumn get createdAt => dateTime()();
}

// --- Database Class ---

@DriftDatabase(tables: [
  MenuCategories,
  MenuItems,
  ItemVariants,
  DiningTables,
  OpsJournal,
])
class AppDatabase extends _$AppDatabase {
  AppDatabase(super.e);

  @override
  int get schemaVersion => 1;

  // --- Data Access Methods (DAOs) ---
  // (These are all correct from before)

  Stream<List<MenuCategory>> watchCategories() =>
      select(menuCategories).watch();

  Stream<List<MenuItem>> watchItemsInCategory(int catId) =>
      (select(menuItems)..where((t) => t.categoryId.equals(catId))).watch();

  Stream<List<ItemVariant>> watchVariantsForItem(int itemId) =>
      (select(itemVariants)..where((t) => t.itemId.equals(itemId))).watch();

  Stream<List<DiningTable>> watchDiningTables() =>
      select(diningTables).watch();

  Future<void> upsertCategory(MenuCategoriesCompanion companion) =>
      into(menuCategories).insertOnConflictUpdate(companion);

  Future<void> upsertMenuItem(MenuItemsCompanion companion) =>
      into(menuItems).insertOnConflictUpdate(companion);

  Future<void> upsertItemVariant(ItemVariantsCompanion companion) =>
      into(itemVariants).insertOnConflictUpdate(companion);

  Future<void> upsertDiningTable(DiningTablesCompanion companion) =>
      into(diningTables).insertOnConflictUpdate(companion);

  Future<void> addPendingOp(OpsJournalCompanion op) =>
      into(opsJournal).insert(op);

  Future<List<OpsJournalEntry>> getPendingOps() =>
      select(opsJournal).get();

  Future<void> clearPendingOps(List<int> ids) =>
      (delete(opsJournal)..where((t) => t.id.isIn(ids))).go();
}

// --- Connection & Provider ---

/// A lazy provider for the database instance
final localDatabaseProvider = Provider<AppDatabase>((ref) {
  final db = AppDatabase(_openConnection());
  ref.onDispose(db.close);
  return db;
});

/// Opens the database connection (NEW SIMPLIFIED VERSION)
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    // Find the documents directory
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'waah_pos.db'));

    // This is all that's needed.
    // The sqlite3_flutter_libs package (which we import above)
    // will handle bundling the correct native libraries for desktop
    // automatically. We don't need the manual workaround.
    return NativeDatabase(file);
  });
}